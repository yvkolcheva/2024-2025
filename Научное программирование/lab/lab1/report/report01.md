---
# Front matter
lang: ru-RU
title: "Лабораторная работа №1"
subtitle: "Научное программирование"
author: "Колчева Юлия Вячеславовна"

# Formatting
toc-title: "Содержание"
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить идеологию и применение средств контроля версий. Освоить умения по работе с git.

# Задание

 Создать базовую конфигурацию для работы с git.
1. Создать ключ SSH.
2. Создать ключ PGP.
3. Настроить подписи git.
4. Зарегистрироваться на Github.
5. Создать локальный каталог для выполнения заданий по предмету.


# Выполнение лабораторной работы

 Создаём учётную запись на https://github.com. (рис. -@fig:001)
![Учетная запись](image/10.png){ #fig:001 width=70% }

Настроем систему контроля версий git, как это описано в лабораторной работе c использованием сервера репозиториев https://github.com/
1) Сначала сделаем предварительную конфигурацию,указав имя и email владельца репозитория: git config --global user.name"Имя Фамилия"git config --global user.email"work@mail" (рис. -@fig:002) Настроим верификацию и подписание коммитов git. Зададим имя начальной ветки.
2) Для последующей идентификации пользователя на сервере репозиториев необходимо сгенерировать пару ключей (приватный и открытый):ssh-keygen -C"Имя Фамилия <work@mail>"Ключи сохраняться в каталоге~/.ssh/. Генерируем ключ двумя способами (рис. -@fig:003)

![Идентификация и создание ключа](image/1.png){ #fig:002 width=70% }
![Создание ключа](image/2.png){ #fig:003 width=70% }

Генерируем ключ pqp командой gpg --full-generate-key (рис. -@fig:004) и следуя инструкциям из лабораторной работы создаём ключ (рис. -@fig:005)

![Создание ключа pgp](image/3.png){ #fig:004 width=70% }
![Настройка ключа](image/4.png){ #fig:005 width=70% }

Выводим список ключей и копируем отпечаток приватного ключа (рис. -@fig:006)

![Список и отпечаток](image/5.png){ #fig:006 width=70% }

Cкопируем наш сгенерированный PGP ключ в буфер обмена (рис. -@fig:007)

![Демонстрация ключа](image/8.png){ #fig:007 width=70% }

Перейдем в настройки GitHub (https://github.com/settings/keys), нажмем на
кнопку New GPG key и вставим полученный ключ в поле ввода(рис. -@fig:008)

![Отображение ключа](image/6.png){ #fig:008 width=70% }

Осталось настроить автоматические подписи с помощью команд: (рис. -@fig:009)

![Отображение ключа](image/9.png){ #fig:009 width=70% }

Далее мы создаём репозиторий на основе шаблона и отправляем все имеющиеся данные на GitHub. (рис. -@fig:010)

![Отображение ключа](image/11.png){ #fig:0010 width=70% }

# Выводы

В ходе выполнения лабораторной работы я изучила идеологию и применение средств контроля версий, а также освоила умения по работе с git.

# Ответы на контрольные вопросы

1) Системы контроля версий (Version Control System,VCS) применяются при работе нескольких человек над одним проектом.

2)В классических системах контроля версий используется централизованная модель,предполагающая наличие единого репозитория для хранения файлов.Выполнение боль-шинства функций по управлению версиями осуществляется специальным сервером.Участник проекта (пользователь) перед началом работы посредством определённыхкоманд получает нужную ему версию файлов.После внесения изменений,пользовательразмещает новую версию в хранилище. При этом предыдущие версии не удаляютсяиз центрального хранилища и к ним можно вернуться в любой момент. Сервер можетсохранятьнеполнуюверсиюизменённыхфайлов,апроизводитьтакназываемуюдельта-компрессию—сохранятьтолько изменения между последовательными версиями,чтопозволяет уменьшить объём хранимых данных. Системы контроля версийтакже могутобеспечиватьдополнительные,более гибкиефункциональные возможности.Например,они могут поддерживать работу с нескольки-ми версиями одного файла,сохраняя общую историю изменений до точки ветвленияверсий и собственные истории изменений каждой ветви.Крометого,обычно доступнаинформация отом,кто из участников,когда и какие изменения вносил.Обычнотакогорода информация хранится в журнале изменений,доступ к которому можно ограничить.В отличие от классических,в распределённых системах контроля версий центральныйрепозиторий не является обязательным.

3)Среди классических VCS наиболее известны CVS, Subversion, а среди распределён-ных — Git, Bazaar, Mercurial. Принципы их работы схожи, отличаются они в основномсинтаксисом используемых в работе команд.

4)Сначала сделаем предварительную конфигурацию,указав имя и email владельца репозитория:git config --global user.name"Имя Фамилия"git config --global user.email"work@mail"и настроив utf-8 в выводе сообщенийgit:git config --global quotepathfalseДля инициализации локального репозитория,расположенного,например,в каталоге~/tutorial,необходимо ввести в командной строке:cdmkdir tutorialcd tutorialgit initПосле это в каталог еtutorial появится каталог.git, в котором будет хранитьсяистория изменений.Создадим тестовый текстовый файлhello.txt и добавим его в локальный репозиторий.
echo'hello world'> hello.txtgit add hello.txtgit commit -am'Новый файл'Воспользуемся командойstatusдля просмотра изменений в рабочем каталоге,сде-ланных с момента последней ревизии:git status.
5) Для последующей идентификации пользователя на сервере репозиториев необходимосгенерировать пару ключей (приватный и открытый):ssh-keygen -C"Имя Фамилия <work@mail>"Ключи сохраняться в каталоге~/.ssh/.Существуетнесколькодоступных серверов репозиториев с возможностью бесплатного размещения данных.Например,https://github.com/.Для работы с ним необходимо сначала завести на сайтеhttps://github.com/учёт-ную запись.Затем необходимо загрузить сгенерённый нами ранее открытый ключ.Для этого зайти на сайтhttps://github.com/под своей учётной записью и перейти в ме-нюGitHub setting.После этого выбрать в боковом менюGitHub settingSSH-ключии нажатькнопкуДобавить клюTimes New Romanч.Скопировав из локальной консоли ключ в буфер обменаcat ~/.ssh/id_rsa.pub | xclip -sel clipвставляем ключ в появившееся на сайте поле.После этого можно создать на сайте репозиторий, выбрав в меню Репозитории Создать репозиторий,дать ему название и сделать общедоступным (публичным).Для загрузки репозитория из локального каталога на сервер выполняем следующиекоманды:git remote add originssh://git@github.com/<username>/<reponame>.gitgit push -u origin masterДалееналокальномкомпьютереможновыполнятьстандартныепроцедурыдляработысgitпри наличии центрального репозитория.

6)У Git две основных задачи: первая —  хранить информацию о всех изменениях в коде, а вторая — обеспечение удобства командной работы над кодом.

7)Наиболее часто используемые командыgit:–создание основного дерева репозитория:git init–получение обновлений (изменений)текущего дерева из центрального репозитория:git pull–отправка всех произведённых изменений локального дерева в центральный репози-торий:git push–просмотр списка изменённых файлов втекущей директории:git status–просмотртекущих изменения:git diff–сохранениетекущих изменений:–добавить все изменённые и/или созданные файлы и/или каталоги:git add .–добавить конкретные изменённые и/или созданные файлы и/или каталоги:git add имена_файлов–удалитьфайли/иликаталогизиндексарепозитория(приэтомфайли/или каталог остаётся в локальной директории):git rm имена_файлов–сохранение добавленных изменений:–сохранить все добавленные изменения и все изменённые файлы:git commit -am'Описание коммита'–сохранитьдобавленные изменения с внесением комментария через встроенныйредактор:git commit–создание новой ветки,базирующейся натекущей:git checkout -b имя_ветки–переключение на некоторую ветку:git checkout имя_ветки(при переключении на ветку,которой ещё нетв локальном репозитории,она будетсоздана и связана с удалённой)–отправка изменений конкретной ветки в центральный репозиторий:git push origin имя_ветки–слияние ветки стекущим деревом:git merge --no-ff имя_ветки–удаление ветки:–удаление локальной уже слитой с основным деревом ветки:git branch -d имя_ветки–принудительное удаление локальной ветки:git branch -D имя_ветки–удаление ветки с центрального репозитория:git push origin :имя_ветки

8) Гид для создания текстового файла
echo'hello world'> hello.txt
git add hello.txt

9)Для фиксации истории проекта в рамках этого процесса вместо одной ветки master используются две ветки.В ветке master хранится официальная история релиза,а ветка develop предназначена для объединения всех функций.
 Ветви решают следующие проблемы
	нужно постоянно создавать архивы с рабочим кодом 
	сложно "переключаться" между архивами 
	сложно перетаскивать изменения между архивами 
	легко запутаться в файлах

10) Во время работы над проектом так или иначе могутсоздаваться файлы,которые нетребуется добавлять в последствии в репозиторий. Например, временные файлы, со-здаваемые редакторами,или объектные файлы,создаваемые компиляторами.Можно прописать шаблоны игнорируемых при добавлении в репозиторий типов файлов в файл.gitignore с помощью сервисов. Для этого сначаланужно получить список имеющихся шаблонов:curl -L -s https://www.gitignore.io/api/listЗатем скачать шаблон,например,для C и C++curl -L -s https://www.gitignore.io/api/c >> .gitignorecurl -L -s https://www.gitignore.io/api/c++ >> .gitignore.


# Список литературы

Лабораторная работа №1

Лабораторная работа № 2. Управление версиями [Электронный ресурс]. 2019. URL:https://esystem.rudn.ru/mod/resource/view.php?id=1154997



